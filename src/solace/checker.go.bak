package solace

import (
	"context"
	"fmt"
	"github.com/hivanov/go-healthcheck/src/core"
	"log"
	"sync"
	"time"

	"github.com/Azure/go-amqp" // Assuming this is the official Go AMQP client for Solace
)

// realSolaceConnection implements solaceConnection for *amqp.Conn.
type realSolaceConnection struct {
	conn *amqp.Conn
}

func (r *realSolaceConnection) Close() error {
	return r.conn.Close()
}

func (r *realSolaceConnection) NewSession(ctx context.Context, opts *amqp.SessionOptions) (solaceSession, error) {
	session, err := r.conn.NewSession(ctx, opts)
	if err != nil {
		return nil, err
	}
	return &realSolaceSession{session: session}, nil
}

// realSolaceSession implements solaceSession for *amqp.Session.
type realSolaceSession struct {
	session *amqp.Session
}

func (r *realSolaceSession) NewSender(ctx context.Context, target string, opts *amqp.SenderOptions) (solaceSender, error) {
	sender, err := r.session.NewSender(ctx, target, opts)
	if err != nil {
		return nil, err
	}
	return &realSolaceSender{sender: sender}, nil
}

func (r *realSolaceSession) NewReceiver(ctx context.Context, source string, opts *amqp.ReceiverOptions) (solaceReceiver, error) {
	receiver, err := r.session.NewReceiver(ctx, source, opts)
	if err != nil {
		return nil, err
	}
	return &realSolaceReceiver{receiver: receiver}, nil
}

func (r *realSolaceSession) Close() error {
	return r.session.Close(context.Background()) // Use a background context for closing
}

// realSolaceSender implements solaceSender for *amqp.Sender.
type realSolaceSender struct {
	sender *amqp.Sender
}

func (r *realSolaceSender) Send(ctx context.Context, msg *amqp.Message, opts *amqp.SendOptions) error {
	return r.sender.Send(ctx, msg, opts)
}

func (r *realSolaceSender) Close() error {
	return r.sender.Close(context.Background()) // Use a background context for closing
}

// realSolaceReceiver implements solaceReceiver for *amqp.Receiver.
type realSolaceReceiver struct {
	receiver *amqp.Receiver
}

func (r *realSolaceReceiver) Receive(ctx context.Context, opts *amqp.ReceiveOptions) (*amqp.Message, error) {
	return r.receiver.Receive(ctx, opts)
}

func (r *realSolaceReceiver) AcceptMessage(ctx context.Context, msg *amqp.Message) error {
	return r.receiver.AcceptMessage(ctx, msg)
}

func (r *realSolaceReceiver) Close() error {
	return r.receiver.Close(context.Background()) // Use a background context for closing
}

type solaceChecker struct {
	checkInterval     time.Duration
	operationsTimeout time.Duration
	connectionString  string
	conn              solaceConnection
	descriptor        core.Descriptor
	currentStatus     core.ComponentStatus
	statusChangeChan  chan core.ComponentStatus
	quit              chan struct{}
	mutex             sync.RWMutex
	cancelFunc        context.CancelFunc
	ctx               context.Context
	disabled          bool
}

// OpenSolaceFunc defines the signature for a function that can open a Solace AMQP connection.
type OpenSolaceFunc func(connectionString string) (solaceConnection, error)

// newRealSolaceConnection is a helper function to create a real solaceConnection from amqp.Conn.
func newRealSolaceConnection(connectionString string) (solaceConnection, error) {
	// Create a context for the Dial operation with a timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) // Using a default 10s timeout for initial dial
	defer cancel()

	// amqp.Dial handles parsing username/password from the URL if present.
	// We only need to configure SASL options if explicit control is needed,
	// or if the URL doesn't contain credentials.
	// For simplicity, let amqp.Dial handle basic auth via URL.

	connOptions := &amqp.ConnOptions{
		Properties: map[string]any{"client-id": fmt.Sprintf("healthcheck-client-%d", time.Now().UnixNano())},
	}

	conn, err := amqp.Dial(ctx, connectionString, connOptions)
	if err != nil {
		return nil, err
	}
	return &realSolaceConnection{conn: conn}, nil
}

// NewSolaceChecker creates a new Solace health checker component.
func NewSolaceChecker(descriptor core.Descriptor, checkInterval, operationsTimeout time.Duration, connectionString string) core.Component {
	return NewSolaceCheckerWithOpenSolaceFunc(descriptor, checkInterval, operationsTimeout, connectionString, newRealSolaceConnection)
}

// NewSolaceCheckerWithOpenSolaceFunc creates a new Solace health checker component,
// allowing a custom OpenSolaceFunc to be provided for opening the connection.
func NewSolaceCheckerWithOpenSolaceFunc(descriptor core.Descriptor, checkInterval, operationsTimeout time.Duration, connectionString string, openSolace OpenSolaceFunc) core.Component {
	solaceConn, err := openSolace(connectionString)
	if err != nil {
		dummyChecker := &solaceChecker{
			descriptor: descriptor,
			currentStatus: core.ComponentStatus{
				Status: core.StatusFail,
				Output: fmt.Sprintf("Failed to open Solace connection: %v", err),
			},
			statusChangeChan: make(chan core.ComponentStatus, 1),
			quit:             make(chan struct{}),
			ctx:              context.Background(),
			cancelFunc:       func() {},
			disabled:         false,
		}
		return dummyChecker
	}

	return newSolaceCheckerInternal(descriptor, checkInterval, operationsTimeout, solaceConn)
}

// newSolaceCheckerInternal creates a new Solace health checker component with a provided solaceConnection.
func newSolaceCheckerInternal(descriptor core.Descriptor, checkInterval, operationsTimeout time.Duration, conn solaceConnection) core.Component {
	ctx, cancelFunc := context.WithCancel(context.Background())

	initialStatus := core.ComponentStatus{
		Status: core.StatusWarn,
		Output: "Solace checker initializing...",
	}

	checker := &solaceChecker{
		checkInterval:     checkInterval,
		operationsTimeout: operationsTimeout,
		descriptor:        descriptor,
		currentStatus:     initialStatus,
		statusChangeChan:  make(chan core.ComponentStatus, 1),
		quit:              make(chan struct{}),
		ctx:               ctx,
		cancelFunc:        cancelFunc,
		disabled:          false,
		conn:              conn,
	}

	go checker.startHealthCheckLoop()

	return checker
}

// Close stops the checker's background operations and closes the Solace connection.
func (s *solaceChecker) Close() error {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	s.cancelFunc()
	close(s.quit)

	if s.conn != nil {
		return s.conn.Close()
	}
	return nil
}

// ChangeStatus updates the internal status of the component.
func (s *solaceChecker) ChangeStatus(newStatus core.ComponentStatus) {
	s.updateStatus(newStatus)
}

// Disable sets the component to a disabled state.
func (s *solaceChecker) Disable() {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	if !s.disabled {
		s.disabled = true
		s.currentStatus = core.ComponentStatus{
			Status:            core.StatusWarn,
			Time:              time.Now().UTC(),
			Output:            "Solace checker disabled",
			AffectedEndpoints: nil,
		}
		select {
		case s.statusChangeChan <- s.currentStatus:
		default:
		}
	}
}

// Enable reactivates the component.
func (s *solaceChecker) Enable() {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	if s.disabled {
		s.disabled = false
		s.currentStatus = core.ComponentStatus{
			Status: core.StatusWarn,
			Output: "Solace checker enabled, re-initializing...",
		}
		select {
		case s.statusChangeChan <- s.currentStatus:
		default:
		}
		go s.performHealthCheck()
	}
}

// Status returns the current health status of the Solace component.
func (s *solaceChecker) Status() core.ComponentStatus {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	return s.currentStatus
}

// Descriptor returns the descriptor for the Solace component.
func (s *solaceChecker) Descriptor() core.Descriptor {
	return s.descriptor
}

// StatusChange returns a channel that sends updates whenever the component's status changes.
func (s *solaceChecker) StatusChange() <-chan core.ComponentStatus {
	return s.statusChangeChan
}

// Health returns a detailed health report for the Solace component.
func (s *solaceChecker) Health() core.ComponentHealth {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	var output string

	if s.currentStatus.Output != "" {
		output = s.currentStatus.Output
	}

	return core.ComponentHealth{
		ComponentID:   s.descriptor.ComponentID,
		ComponentType: s.descriptor.ComponentType,
		Status:        s.currentStatus.Status,
		Output:        output,
	}
}

// startHealthCheckLoop runs in a goroutine, periodically checking the Solace health.
func (s *solaceChecker) startHealthCheckLoop() {
	ticker := time.NewTicker(s.checkInterval)
	defer ticker.Stop()

	s.performHealthCheck()

	for {
		select {
		case <-ticker.C:
			s.performHealthCheck()
		case <-s.quit:
			if s.conn != nil {
				if err := s.conn.Close(); err != nil {
					log.Printf("Error closing Solace connection on quit: %v", err)
				}
			}
			return
		case <-s.ctx.Done():
			if s.conn != nil {
				if err := s.conn.Close(); err != nil {
					log.Printf("Error closing Solace connection on context done: %v", err)
				}
			}
			return
		}
	}
}

// performHealthCheck attempts to create a session and send a test message.
func (s *solaceChecker) performHealthCheck() {
	s.mutex.RLock()
	isDisabled := s.disabled
	s.mutex.RUnlock()

	if isDisabled {
		return
	}

	if s.conn == nil {
		s.updateStatus(core.ComponentStatus{
			Status: core.StatusFail,
			Output: "Solace connection is nil",
		})
		return
	}

	// Context for individual operations
	opCtx, cancelOp := context.WithTimeout(s.ctx, s.operationsTimeout)
	defer cancelOp()

	startTime := time.Now()

	// 1. Create a session
	session, err := s.conn.NewSession(opCtx, nil) // Pass opCtx and SessionOptions
	if err != nil {
		s.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("Failed to create Solace session: %v", err),
			Time:          startTime,
			ObservedValue: time.Since(startTime).Seconds(),
			ObservedUnit:  "s",
		})
		return
	}
	defer func() {
		if err := session.Close(); err != nil {
			log.Printf("Error closing Solace session: %v", err)
		}
	}()

	// 2. Create a temporary topic for sending/receiving a test message
	testTopic := fmt.Sprintf("healthcheck/test/%s", s.descriptor.ComponentID)

	sender, err := session.NewSender(opCtx, testTopic, nil) // Pass opCtx, target, SenderOptions
	if err != nil {
		s.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("Failed to create Solace sender for topic '%s': %v", testTopic, err),
			Time:          startTime,
			ObservedValue: time.Since(startTime).Seconds(),
			ObservedUnit:  "s",
		})
		return
	}
	defer func() {
		if err := sender.Close(); err != nil { // Pass opCtx to Close
			log.Printf("Error closing Solace sender: %v", err)
		}
	}()

	receiver, err := session.NewReceiver(opCtx, testTopic, nil) // Pass opCtx, source, ReceiverOptions
	if err != nil {
		s.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("Failed to create Solace receiver for topic '%s': %v", testTopic, err),
			Time:          startTime,
			ObservedValue: time.Since(startTime).Seconds(),
			ObservedUnit:  "s",
		})
		return
	}
	defer func() {
		if err := receiver.Close(); err != nil { // Pass opCtx to Close
			log.Printf("Error closing Solace receiver: %v", err)
		}
	}()

	// 3. Send a test message
	msg := amqp.NewMessage([]byte("Solace health check message"))
	err = sender.Send(opCtx, msg, nil) // Use context with timeout for send, SendOptions
	if err != nil {
		s.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("Failed to send Solace test message: %v", err),
			Time:          startTime,
			ObservedValue: time.Since(startTime).Seconds(),
			ObservedUnit:  "s",
		})
		return
	}

	// 4. Receive the test message (with timeout)
	receivedMsg, err := receiver.Receive(opCtx, nil) // Use context with timeout for receive, ReceiveOptions
	if err != nil {
		s.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("Failed to receive Solace test message: %v", err),
			Time:          startTime,
			ObservedValue: time.Since(startTime).Seconds(),
			ObservedUnit:  "s",
		})
		return
	}
	err = receiver.AcceptMessage(opCtx, receivedMsg) // Use AcceptMessage with context
	if err != nil {
		log.Printf("Error accepting Solace message: %v", err)
	}

	s.updateStatus(core.ComponentStatus{
		Status:        core.StatusPass,
		Output:        "Solace is healthy and messages are flowing",
		Time:          startTime,
		ObservedValue: time.Since(startTime).Seconds(),
		ObservedUnit:  "s",
	})
}

// updateStatus safely updates the current status and notifies listeners if the status has changed.
func (s *solaceChecker) updateStatus(newStatus core.ComponentStatus) {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	if s.currentStatus.Status != newStatus.Status || s.currentStatus.Output != newStatus.Output {
		s.currentStatus = newStatus
		select {
		case s.statusChangeChan <- newStatus:
		default:
			// Non-blocking send
		}
	}
}
