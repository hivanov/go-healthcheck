package mongodb

import (
	"context"
	"fmt"
	"github.com/hivanov/go-healthcheck/src/core"
	"sync"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
)

// mongoConnection is an interface for a MongoDB client, for mocking in tests.
type mongoConnection interface {
	Ping(ctx context.Context, rp *readpref.ReadPref) error
	Disconnect(ctx context.Context) error
}

type mongoChecker struct {
	checkInterval    time.Duration
	pingTimeout      time.Duration // New field for ping timeout
	connectionString string
	client           mongoConnection
	descriptor       core.Descriptor
	currentStatus    core.ComponentStatus
	statusChangeChan chan core.ComponentStatus
	quit             chan struct{}
	mutex            sync.RWMutex
	cancelFunc       context.CancelFunc
	ctx              context.Context
	disabled         bool
}

// OpenDBFunc defines the signature for a function that can open a database connection.
type OpenDBFunc func(ctx context.Context, opts *options.ClientOptions) (mongoConnection, error)

// newMongoConnection is a helper function to create a real mongoConnection.
func newMongoConnection(ctx context.Context, opts *options.ClientOptions) (mongoConnection, error) {
	client, err := mongo.Connect(ctx, opts)
	if err != nil {
		return nil, err
	}
	// Ping the server to ensure a connection is established.
	if err := client.Ping(ctx, readpref.Primary()); err != nil {
		return nil, err
	}
	return client, nil
}

// NewMongoChecker creates a new MongoDB health checker component.
func NewMongoChecker(descriptor core.Descriptor, checkInterval, pingTimeout time.Duration, connectionString string) core.Component {
	clientOptions := options.Client().ApplyURI(connectionString)
	return NewMongoCheckerWithOptions(descriptor, checkInterval, pingTimeout, clientOptions)
}

// NewMongoCheckerWithOptions creates a new MongoDB health checker component with the given client options.
func NewMongoCheckerWithOptions(descriptor core.Descriptor, checkInterval, pingTimeout time.Duration, clientOptions *options.ClientOptions) core.Component {
	return NewMongoCheckerWithOpenDBFunc(descriptor, checkInterval, pingTimeout, clientOptions, newMongoConnection)
}

// NewMongoCheckerWithOpenDBFunc creates a new MongoDB health checker component with a custom OpenDBFunc.
func NewMongoCheckerWithOpenDBFunc(descriptor core.Descriptor, checkInterval, pingTimeout time.Duration, clientOptions *options.ClientOptions, openDB OpenDBFunc) core.Component {
	client, err := openDB(context.Background(), clientOptions)
	if err != nil {
		return &mongoChecker{
			descriptor: descriptor,
			currentStatus: core.ComponentStatus{
				Status: core.StatusFail,
				Output: fmt.Sprintf("Failed to create MongoDB client: %v", err),
			},
			statusChangeChan: make(chan core.ComponentStatus, 1),
			quit:             make(chan struct{}),
			ctx:              context.Background(),
			cancelFunc:       func() {},
		}
	}

	return newMongoCheckerInternal(descriptor, checkInterval, pingTimeout, client, clientOptions.GetURI())
}

// newMongoCheckerInternal creates a new MongoDB health checker component with a provided mongoConnection.
func newMongoCheckerInternal(descriptor core.Descriptor, checkInterval, pingTimeout time.Duration, client mongoConnection, connectionString string) core.Component {
	ctx, cancelFunc := context.WithCancel(context.Background())

	checker := &mongoChecker{
		checkInterval:    checkInterval,
		pingTimeout:      pingTimeout, // Initialize pingTimeout
		connectionString: connectionString,
		client:           client,
		descriptor:       descriptor,
		currentStatus: core.ComponentStatus{
			Status: core.StatusWarn,
			Output: "MongoDB checker initializing...",
		},
		statusChangeChan: make(chan core.ComponentStatus, 1),
		quit:             make(chan struct{}),
		ctx:              ctx,
		cancelFunc:       cancelFunc,
	}

	go checker.startHealthCheckLoop()

	return checker
}

func (m *mongoChecker) Close() error {
	m.cancelFunc()
	close(m.quit)
	if m.client != nil {
		return m.client.Disconnect(context.Background())
	}
	return nil
}

func (m *mongoChecker) ChangeStatus(newStatus core.ComponentStatus) {
	m.updateStatus(newStatus)
}

func (m *mongoChecker) Disable() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	if !m.disabled {
		m.disabled = true
		m.currentStatus = core.ComponentStatus{
			Status: core.StatusWarn,
			Time:   time.Now().UTC(),
			Output: "MongoDB checker disabled",
		}
		select {
		case m.statusChangeChan <- m.currentStatus:
		default:
		}
	}
}

func (m *mongoChecker) Enable() {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	if m.disabled {
		m.disabled = false
		m.currentStatus = core.ComponentStatus{
			Status: core.StatusWarn,
			Output: "MongoDB checker enabled, re-initializing...",
		}
		select {
		case m.statusChangeChan <- m.currentStatus:
		default:
		}
		go m.performHealthCheck()
	}
}

func (m *mongoChecker) Status() core.ComponentStatus {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.currentStatus
}

func (m *mongoChecker) Descriptor() core.Descriptor {
	return m.descriptor
}

func (m *mongoChecker) StatusChange() <-chan core.ComponentStatus {
	return m.statusChangeChan
}

func (m *mongoChecker) Health() core.ComponentHealth {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return core.ComponentHealth{
		ComponentID:   m.descriptor.ComponentID,
		ComponentType: m.descriptor.ComponentType,
		Status:        m.currentStatus.Status,
		Output:        m.currentStatus.Output,
	}
}

func (m *mongoChecker) startHealthCheckLoop() {
	ticker := time.NewTicker(m.checkInterval)
	defer ticker.Stop()

	m.performHealthCheck()

	for {
		select {
		case <-ticker.C:
			m.performHealthCheck()
		case <-m.quit:
			return
		case <-m.ctx.Done():
			return
		}
	}
}

func (m *mongoChecker) performHealthCheck() {
	m.mutex.RLock()
	isDisabled := m.disabled
	m.mutex.RUnlock()

	if isDisabled {
		return
	}

	if m.client == nil {
		m.updateStatus(core.ComponentStatus{
			Status: core.StatusFail,
			Output: "MongoDB client is nil",
		})
		return
	}

	startTime := time.Now()
	pingCtx, cancelPing := context.WithTimeout(m.ctx, m.pingTimeout)
	defer cancelPing()
	err := m.client.Ping(pingCtx, readpref.Primary())
	elapsedTime := time.Since(startTime)

	if err != nil {
		m.updateStatus(core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("MongoDB health check failed: %v", err),
			Time:          startTime,
			ObservedValue: elapsedTime.Seconds(),
			ObservedUnit:  "s",
		})
	} else {
		m.updateStatus(core.ComponentStatus{
			Status:        core.StatusPass,
			Output:        "MongoDB is healthy",
			Time:          startTime,
			ObservedValue: elapsedTime.Seconds(),
			ObservedUnit:  "s",
		})
	}
}

func (m *mongoChecker) updateStatus(newStatus core.ComponentStatus) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.currentStatus.Status != newStatus.Status || m.currentStatus.Output != newStatus.Output {
		m.currentStatus = newStatus
		select {
		case m.statusChangeChan <- newStatus:
		default:
		}
	}
}
