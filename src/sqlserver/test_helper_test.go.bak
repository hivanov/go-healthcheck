package sqlserver

import (
	"context"
	"github.com/hivanov/go-healthcheck/src/core"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/mssql"
	"github.com/testcontainers/testcontainers-go/wait" // Import the wait package
)

// setupSQLServerContainer starts a Microsoft SQL Server container and returns its connection string.
// It also returns a cleanup function to stop the container.
func setupSQLServerContainer(tb testing.TB, ctx context.Context) (testcontainers.Container, string, func()) {
	// Create a context with a timeout for container startup
	startupCtx, startupCancel := context.WithTimeout(ctx, 5*time.Minute) // Increased timeout for SQL Server container startup
	defer startupCancel()

	password := "Strong_Password_123!" // SQL Server requires a strong password

	mssqlContainer, err := mssql.Run(startupCtx, // Use startupCtx
		"mcr.microsoft.com/mssql/server:2019-latest",
		mssql.WithPassword(password),
		mssql.WithAcceptEULA(), // Corrected: no boolean argument
		testcontainers.WithWaitStrategy(
			wait.ForLog("Recovery is complete").WithStartupTimeout(5*time.Minute), // Corrected: use wait.ForLog
		),
	)
	if err != nil {
		tb.Fatalf("Failed to start Microsoft SQL Server container: %v", err) // Use tb
	}

	require.NotNil(tb, mssqlContainer, "Microsoft SQL Server container is nil") // Use tb

	// Get the connection string. Default port for MSSQL is 1433.
	// The mssql module for testcontainers-go typically provides a direct way.
	connStr, err := mssqlContainer.ConnectionString(startupCtx, "testuser", password, "testdb")
	if err != nil && mssqlContainer != nil {
		_ = mssqlContainer.Terminate(startupCtx)              // Use startupCtx
		tb.Fatalf("Failed to get connection string: %v", err) // Use tb
	}

	return mssqlContainer, connStr, func() {
		if err := mssqlContainer.Terminate(ctx); err != nil { // Use passed ctx for termination
			tb.Logf("Failed to terminate Microsoft SQL Server container: %v", err) // Use tb
		}
	}
}

// waitForStatus helper waits for the checker to report a specific status.
func waitForStatus(tb testing.TB, checker core.Component, expectedStatus core.StatusEnum, timeout time.Duration) {
	tb.Helper()
	ctx, cancel := context.WithTimeout(context.Background(), timeout) // Use context.Background()
	defer cancel()

	statusChangeChan := checker.StatusChange()

	// Check current status first
	currentStatus := checker.Status()
	if currentStatus.Status == expectedStatus {
		return
	}

	for {
		select {
		case <-ctx.Done():
			tb.Fatalf("Timed out waiting for status '%s'. Current status: '%s', Output: '%s'", expectedStatus, checker.Status().Status, checker.Status().Output) // Use tb
		case newStatus := <-statusChangeChan:
			if newStatus.Status == expectedStatus {
				return
			}
		case <-time.After(5 * time.Millisecond): // Small delay to avoid busy-waiting for initial status
			currentStatus = checker.Status()
			if currentStatus.Status == expectedStatus {
				return
			}
		}
	}
}
