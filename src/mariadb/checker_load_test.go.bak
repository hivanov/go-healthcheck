package mariadb

import (
	"context"
	"github.com/hivanov/go-healthcheck/src/core"
	"sync"
	"sync/atomic"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	minCallsPerSecond = 200
	testDuration      = 2 * time.Second
	testConcurrency   = 50
)

// TestMariaDBChecker_StatusLoad_WithRealDB tests the load handling of the Status() method against a real containerized DB.
// It verifies that Status() performs well even when the database goes down.
func TestMariaDBChecker_StatusLoad_WithRealDB(t *testing.T) {
	ctx := context.Background()
	mariadbContainer, connStr, cleanup := setupMariaDBContainer(t, ctx)
	defer cleanup()

	desc := core.Descriptor{ComponentID: "mariadb-load-test-real-db", ComponentType: "mariadb"}
	checkInterval := 100 * time.Millisecond
	queryTimeout := 5 * time.Second

	checker, err := New(desc, checkInterval, queryTimeout, connStr)
	require.NoError(t, err)
	defer func() {
		assert.NoError(t, checker.Close(), "Checker Close() returned an unexpected error")
	}()

	// Wait for the checker to become healthy first
	waitForStatus(t, checker, core.StatusPass, 20*time.Second)

	var stopWg sync.WaitGroup
	stopWg.Add(1)
	// Start a goroutine to stop the container after a short delay
	go func() {
		defer stopWg.Done()
		time.Sleep(testDuration / 2) // Stop container halfway through the test
		t.Log("Stopping MariaDB container during load test...")
		if err := mariadbContainer.Stop(ctx, nil); err != nil {
			t.Logf("Failed to stop MariaDB container: %v", err)
		}
		t.Log("MariaDB container stopped during load test.")
	}()

	var totalCalls int64
	var wg sync.WaitGroup
	wg.Add(testConcurrency)

	startTime := time.Now()

	for i := 0; i < testConcurrency; i++ {
		go func() {
			defer wg.Done()
			for time.Since(startTime) < testDuration {
				_ = checker.Status()
				atomic.AddInt64(&totalCalls, 1)
			}
		}()
	}

	wg.Wait()
	stopWg.Wait() // Ensure container stop goroutine finishes

	duration := time.Since(startTime)
	actualCallsPerSecond := float64(atomic.LoadInt64(&totalCalls)) / duration.Seconds()

	t.Logf("Status() method (with real DB) handled %d calls in %v", totalCalls, duration)
	t.Logf("Actual calls per second (with real DB): %.2f", actualCallsPerSecond)

	assert.GreaterOrEqual(t, actualCallsPerSecond, float64(minCallsPerSecond), "Status() method should handle at least %d calls per second even when DB goes down", minCallsPerSecond)

	// Final check: the checker should be in a Fail state
	waitForStatus(t, checker, core.StatusFail, 10*time.Second)
}
