package mariadb

import (
	"context"
	"testing"
	"time"

	"github.com/hivanov/go-healthcheck/src/core"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// waitForStatus is a test helper to wait for a specific status from the checker.
func waitForStatus(t *testing.T, c *Checker, expectedStatus core.StatusEnum, timeout time.Duration) {
	t.Helper()
	timer := time.NewTimer(timeout)
	defer timer.Stop()

	// Check initial status immediately
	if c.Status().Status == expectedStatus {
		return
	}

	statusCh := c.StatusChange()
	for {
		select {
		case status := <-statusCh:
			if status.Status == expectedStatus {
				return
			}
		case <-timer.C:
			t.Fatalf("timed out waiting for status %q, last status was %q", expectedStatus, c.Status().Status)
		}
	}
}

// TestMariaDBChecker_Integration_HappyPath tests a successful connection and health check.
func TestMariaDBChecker_Integration_HappyPath(t *testing.T) {
	ctx := context.Background()
	_, connStr, cleanup := setupMariaDBContainer(t, ctx)
	defer cleanup()

	desc := core.Descriptor{ComponentID: "mariadb-happy-path", ComponentType: "mariadb"}
	checkInterval := 100 * time.Millisecond
	queryTimeout := 5 * time.Second

	checker, err := New(desc, checkInterval, queryTimeout, connStr)
	require.NoError(t, err)
	defer func() {
		assert.NoError(t, checker.Close(), "Checker Close() returned an unexpected error")
	}()

	// Expect initial 'Warn' then transition to 'Pass'
	waitForStatus(t, checker, core.StatusPass, 20*time.Second)

	status := checker.Status()
	assert.Equal(t, core.StatusPass, status.Status, "Expected final status to be 'pass'")
	assert.Equal(t, "MariaDB is healthy", status.Output)
	assert.NotZero(t, status.ObservedValue, "Expected ObservedValue to be non-zero")
	assert.Equal(t, "s", status.ObservedUnit, "Expected ObservedUnit 's'")

	// Test Descriptor
	assert.Equal(t, desc, checker.Descriptor())
}

// TestMariaDBChecker_Integration_Fail_NoConnection tests when the database is unreachable.
func TestMariaDBChecker_Integration_Fail_NoConnection(t *testing.T) {
	invalidConnStr := "user=baduser dbname=baddb host=localhost port=1234"

	desc := core.Descriptor{ComponentID: "mariadb-fail-noconn", ComponentType: "mariadb"}
	checkInterval := 100 * time.Millisecond
	queryTimeout := 1 * time.Second

	checker, err := New(desc, checkInterval, queryTimeout, invalidConnStr)
	require.Error(t, err)
	require.Nil(t, checker)
	require.Contains(t, err.Error(), "invalid DSN")
}

// TestMariaDBChecker_Integration_Fail_DBDown tests the checker reacting to a database going down.
func TestMariaDBChecker_Integration_Fail_DBDown(t *testing.T) {
	ctx := context.Background()
	mariadbContainer, connStr, cleanup := setupMariaDBContainer(t, ctx)
	// Don't defer cleanup immediately, we need to control it

	desc := core.Descriptor{ComponentID: "mariadb-fail-dbdown", ComponentType: "mariadb"}
	checkInterval := 100 * time.Millisecond
	queryTimeout := 5 * time.Second

	checker, err := New(desc, checkInterval, queryTimeout, connStr)
	require.NoError(t, err)

	// Wait for it to become healthy first
	waitForStatus(t, checker, core.StatusPass, 20*time.Second)

	// Now stop the container
	t.Log("Stopping MariaDB container...")
	err = mariadbContainer.Stop(ctx, nil)
	require.NoError(t, err, "Failed to stop MariaDB container")
	t.Log("MariaDB container stopped.")

	// It should now transition to a Fail state
	waitForStatus(t, checker, core.StatusFail, 10*time.Second)

	status := checker.Status()
	require.Equal(t, core.StatusFail, status.Status, "Expected status 'fail' after container stopped")
	require.Contains(t, status.Output, "MariaDB health check failed", "Expected output message indicating connection error")

	// Now cleanup everything
	cleanup()
	assert.NoError(t, checker.Close(), "Checker Close() returned an unexpected error")
}

// TestMariaDBChecker_Close tests graceful shutdown.
func TestMariaDBChecker_Close(t *testing.T) {
	ctx := context.Background()
	_, connStr, cleanup := setupMariaDBContainer(t, ctx)
	defer cleanup()

	desc := core.Descriptor{ComponentID: "mariadb-close", ComponentType: "mariadb"}
	checkInterval := 50 * time.Millisecond
	queryTimeout := 5 * time.Second

	checker, err := New(desc, checkInterval, queryTimeout, connStr)
	require.NoError(t, err)

	// Wait for it to become healthy first
	waitForStatus(t, checker, core.StatusPass, 20*time.Second)

	// Close the checker
	err = checker.Close()
	require.NoError(t, err, "Close() returned an unexpected error")

	// The status change channel should be closed
	select {
	case _, ok := <-checker.StatusChange():
		require.False(t, ok, "StatusChange() channel should be closed after Close()")
	case <-time.After(1 * time.Second):
		t.Fatal("timed out waiting for StatusChange() channel to close")
	}
}
