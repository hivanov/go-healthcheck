package mariadb

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/hivanov/go-healthcheck/src/core"
	"sync"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

// Checker is a health checker for MariaDB.
type Checker struct {
	descriptor    core.Descriptor
	checkInterval time.Duration
	queryTimeout  time.Duration
	db            *sql.DB

	mu         sync.RWMutex
	lastStatus core.ComponentStatus
	stop       context.CancelFunc
	wg         sync.WaitGroup

	statusChange chan core.ComponentStatus
}

var _ core.Component = (*Checker)(nil)

// New creates a new MariaDB health checker.
func New(descriptor core.Descriptor, checkInterval, queryTimeout time.Duration, connectionString string) (*Checker, error) {
	db, err := sql.Open("mysql", connectionString)
	if err != nil {
		return nil, fmt.Errorf("failed to open database connection: %w", err)
	}

	ctx, cancel := context.WithCancel(context.Background())

	c := &Checker{
		descriptor:    descriptor,
		checkInterval: checkInterval,
		queryTimeout:  queryTimeout,
		db:            db,
		lastStatus: core.ComponentStatus{
			Status: core.StatusWarn,
			Output: "MariaDB checker initializing...",
		},
		stop:         cancel,
		statusChange: make(chan core.ComponentStatus, 1),
	}

	c.wg.Add(1)
	go c.run(ctx)

	return c, nil
}

// Close stops the checker and closes the database connection.
func (c *Checker) Close() error {
	c.stop()
	c.wg.Wait()
	close(c.statusChange)
	return c.db.Close()
}

// Status returns the current health status of the MariaDB component.
func (c *Checker) Status() core.ComponentStatus {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.lastStatus
}

// Descriptor returns the descriptor for the MariaDB component.
func (c *Checker) Descriptor() core.Descriptor {
	return c.descriptor
}

// StatusChange returns a channel that sends updates whenever the component's status changes.
func (c *Checker) StatusChange() <-chan core.ComponentStatus {
	return c.statusChange
}

func (c *Checker) run(ctx context.Context) {
	defer c.wg.Done()

	ticker := time.NewTicker(c.checkInterval)
	defer ticker.Stop()

	c.performCheck(ctx) // Perform initial check

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			c.performCheck(ctx)
		}
	}
}

func (c *Checker) performCheck(ctx context.Context) {
	checkCtx, cancel := context.WithTimeout(ctx, c.queryTimeout)
	defer cancel()

	startTime := time.Now()
	err := c.db.PingContext(checkCtx)
	elapsedTime := time.Since(startTime)

	var newStatus core.ComponentStatus
	if err != nil {
		newStatus = core.ComponentStatus{
			Status:        core.StatusFail,
			Output:        fmt.Sprintf("MariaDB health check failed: %v", err),
			Time:          startTime,
			ObservedValue: elapsedTime.Seconds(),
			ObservedUnit:  "s",
		}
	} else {
		newStatus = core.ComponentStatus{
			Status:        core.StatusPass,
			Output:        "MariaDB is healthy",
			Time:          startTime,
			ObservedValue: elapsedTime.Seconds(),
			ObservedUnit:  "s",
		}
	}

	c.updateStatus(newStatus)
}

func (c *Checker) updateStatus(newStatus core.ComponentStatus) {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.lastStatus.Status != newStatus.Status || c.lastStatus.Output != newStatus.Output {
		c.lastStatus = newStatus
		select {
		case c.statusChange <- newStatus:
		default:
			// Non-blocking send
		}
	}
}

// The following methods are no-ops to satisfy the core.Component interface.
// They are not used in this simplified checker.

// ChangeStatus is a no-op.
func (c *Checker) ChangeStatus(core.ComponentStatus) {}

// Disable is a no-op.
func (c *Checker) Disable() {}

// Enable is a no-op.
func (c *Checker) Enable() {}

// Health is a no-op.
func (c *Checker) Health() core.ComponentHealth {
	c.mu.RLock()
	status := c.lastStatus
	c.mu.RUnlock()

	descriptor := c.Descriptor()
	return core.ComponentHealth{
		Status:            status.Status,
		Version:           descriptor.Version,
		ReleaseID:         descriptor.ReleaseID,
		Notes:             descriptor.Notes,
		Output:            status.Output,
		Links:             descriptor.Links,
		ServiceID:         descriptor.ServiceID,
		Description:       descriptor.Description,
		ComponentID:       descriptor.ComponentID,
		ComponentType:     descriptor.ComponentType,
		ObservedValue:     status.ObservedValue,
		ObservedUnit:      status.ObservedUnit,
		AffectedEndpoints: status.AffectedEndpoints,
		Time:              status.Time,
	}
}
