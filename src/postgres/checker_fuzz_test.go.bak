package postgres

import (
	"github.com/hivanov/go-healthcheck/src/core"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func FuzzPostgresChecker_NewPostgresChecker(f *testing.F) {
	f.Add("user=test password=password host=localhost port=5432 dbname=test sslmode=disable")
	f.Fuzz(func(t *testing.T, connectionString string) {
		descriptor := core.Descriptor{
			ComponentID:   "fuzz-test",
			ComponentType: "postgres",
		}
		checkInterval := 10 * time.Millisecond // Shorter interval for fuzzing
		queryTimeout := 50 * time.Millisecond  // Short query timeout for fuzzing

		// We call NewPostgresChecker, which is the public entry point.
		// We expect this function to not panic.
		checker := NewPostgresChecker(descriptor, checkInterval, queryTimeout, connectionString)
		defer func() {
			if err := checker.Close(); err != nil {
				t.Errorf("Checker Close() returned an unexpected error: %v", err)
			}
		}()

		if checker == nil {
			t.Skipf("NewPostgresChecker returned nil for connection string: %s", connectionString)
			return
		}

		// Exercise other methods
		_ = checker.Status()
		_ = checker.Descriptor()
		_ = checker.Health()
		checker.Disable()
		checker.Enable()
		checker.ChangeStatus(core.ComponentStatus{Status: core.StatusFail, Output: "fuzz"})

		// Allow some time for goroutines to process if necessary
		time.Sleep(checkInterval * 2)

		status := checker.Status()
		// Depending on the connection string, status could be Warn (initializing/disabled) or Fail (connection error).
		// We primarily care that it doesn't panic and that the status is one of the expected ones.
		assert.True(t, status.Status == core.StatusWarn || status.Status == core.StatusFail,
			"Unexpected status %s for connection string: %s", status.Status, connectionString)
	})
}
