package rabbitmq

import (
	"context"
	"fmt"
	"github.com/hivanov/go-healthcheck/src/core"
	"log"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestRabbitMQHealthCheck_Pass verifies that the health check passes when RabbitMQ is healthy.
func TestRabbitMQHealthCheck_Pass(t *testing.T) {
	ctx, cancel := context.WithTimeout(t.Context(), defaultTestTimeout)
	defer cancel()
	rabbitmqContainer, amqpURL, err := setupRabbitMQ(ctx)
	require.NoError(t, err)
	defer func() {
		if err := rabbitmqContainer.Terminate(ctx); err != nil {
			log.Printf("failed to terminate RabbitMQ container: %s", err)
		}
	}()

	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-pass",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check passing test",
	}

	checker := NewRabbitMQChecker(descriptor, 1*time.Second, 1*time.Second, amqpURL)
	defer func() {
		if err := checker.Close(); err != nil {
			assert.NoError(t, err)
		}
	}()

	// Wait for the checker to report a PASS status
	waitForStatus(t, checker, core.StatusPass, defaultTestTimeout)

	status := checker.Status()
	require.Equal(t, core.StatusPass, status.Status, "Expected status to be PASS")
	require.Contains(t, status.Output, "RabbitMQ is healthy", "Expected output to indicate health")

	health := checker.Health()
	require.Equal(t, core.StatusPass, health.Status, "Expected health status to be PASS")
	require.Contains(t, health.Output, "RabbitMQ is healthy", "Expected health output to indicate health")
}

// TestRabbitMQHealthCheck_Fail verifies that the health check fails when RabbitMQ is unavailable.
func TestRabbitMQHealthCheck_Fail(t *testing.T) {
	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-fail",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check failing test",
	}

	// Use a connection string that will fail
	badAmqpURL := "amqp://guest:guest@localhost:5679/bad_host"

	checker := NewRabbitMQChecker(descriptor, 1*time.Second, 1*time.Second, badAmqpURL)
	defer func() {
		if err := checker.Close(); err != nil {
			assert.NoError(t, err)
		}
	}()

	// Wait for the checker to report a FAIL status
	waitForStatus(t, checker, core.StatusFail, defaultTestTimeout)

	status := checker.Status()
	require.Equal(t, core.StatusFail, status.Status, "Expected status to be FAIL")
	require.Contains(t, status.Output, "Failed to open RabbitMQ connection", "Expected output to indicate connection failure")

	health := checker.Health()
	require.Equal(t, core.StatusFail, health.Status, "Expected health status to be FAIL")
	require.Contains(t, health.Output, "Failed to open RabbitMQ connection", "Expected health output to indicate connection failure")
}

// TestRabbitMQHealthCheck_Close verifies that closing the checker works correctly.
func TestRabbitMQHealthCheck_Close(t *testing.T) {
	ctx, cancel := context.WithTimeout(t.Context(), defaultTestTimeout)
	defer cancel()
	rabbitmqContainer, amqpURL, err := setupRabbitMQ(ctx)
	require.NoError(t, err)
	defer func() {
		if err := rabbitmqContainer.Terminate(ctx); err != nil {
			log.Printf("failed to terminate RabbitMQ container: %s", err)
		}
	}()

	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-close",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check close test",
	}

	checker := NewRabbitMQChecker(descriptor, 1*time.Second, 1*time.Second, amqpURL)
	// Wait for the checker to start and report a PASS status
	waitForStatus(t, checker, core.StatusPass, defaultTestTimeout)

	err = checker.Close()
	require.NoError(t, err, "Expected no error when closing the checker")

	// After closing, the status should eventually reflect a stopped state or retain last known good status
	// The exact behavior depends on how the checker handles being closed.
	// For now, let's just ensure it doesn't panic and the Close method returns no error.
}

// TestRabbitMQHealthCheck_ChangeStatus verifies ChangeStatus method.
func TestRabbitMQHealthCheck_ChangeStatus(t *testing.T) {
	ctx, cancel := context.WithTimeout(t.Context(), defaultTestTimeout)
	defer cancel()
	rabbitmqContainer, amqpURL, err := setupRabbitMQ(ctx)
	require.NoError(t, err)
	defer func() {
		if err := rabbitmqContainer.Terminate(ctx); err != nil {
			log.Printf("failed to terminate RabbitMQ container: %s", err)
		}
	}()

	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-change-status",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check change status test",
	}

	checker := NewRabbitMQChecker(descriptor, 1*time.Minute, 1*time.Second, amqpURL) // Long interval to prevent auto-updates
	defer func() {
		if err := checker.Close(); err != nil {
			assert.NoError(t, err)
		}
	}()

	initialStatus := checker.Status()
	require.Equal(t, core.StatusWarn, initialStatus.Status, "Expected initial status to be WARN")

	// Wait for the initial WARN status to be observed in the background loop
	// (though this is already the initial status set by the checker)
	waitForStatus(t, checker, core.StatusWarn, defaultTestTimeout)

	newStatus := core.ComponentStatus{
		Status: core.StatusFail,
		Output: "Manually set to critical",
	}
	checker.ChangeStatus(newStatus)

	// Wait for the manually changed status to propagate and be reflected
	waitForStatus(t, checker, core.StatusFail, defaultTestTimeout)

	changedStatus := checker.Status()
	require.Equal(t, core.StatusFail, changedStatus.Status, "Expected status to be CRIT after change")
	require.Equal(t, "Manually set to critical", changedStatus.Output, "Expected output to match manual set")
}

// TestRabbitMQHealthCheck_DisableEnable verifies Disable and Enable methods.
func TestRabbitMQHealthCheck_DisableEnable(t *testing.T) {
	ctx, cancel := context.WithTimeout(t.Context(), defaultTestTimeout)
	defer cancel()
	rabbitmqContainer, amqpURL, err := setupRabbitMQ(ctx)
	require.NoError(t, err)
	defer func() {
		if err := rabbitmqContainer.Terminate(ctx); err != nil {
			log.Printf("failed to terminate RabbitMQ container: %s", err)
		}
	}()

	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-disable-enable",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check disable/enable test",
	}

	checker := NewRabbitMQChecker(descriptor, 1*time.Second, 1*time.Second, amqpURL)
	defer func() {
		if err := checker.Close(); err != nil {
			assert.NoError(t, err)
		}
	}()

	statusChan := checker.StatusChange()

	// The initial status is WARN, but it immediately starts a health check
	// which will likely change the status to PASS very quickly.
	// We'll consume statuses from the channel until we see PASS.
	// We expect at least one status update.
	var initialStatus core.ComponentStatus
	select {
	case initialStatus = <-statusChan:
		// We might get WARN first, or PASS directly if the check is fast
		require.True(t, initialStatus.Status == core.StatusWarn || initialStatus.Status == core.StatusPass, "Expected initial status from channel to be WARN or PASS")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for initial status update")
	}

	// If the first status was WARN, wait for PASS. If it was PASS, we are good.
	if initialStatus.Status == core.StatusWarn {
		select {
		case status := <-statusChan:
			require.Equal(t, core.StatusPass, status.Status, "Expected PASS status from channel after initial WARN")
		case <-time.After(defaultTestTimeout):
			t.Fatal("Timeout waiting for PASS status after initial WARN")
		}
	} else {
		// If initial status was PASS, we are good to go.
		// No further action needed here.
	}

	checker.Disable()
	// Wait for the WARN status after disabling
	select {
	case status := <-statusChan:
		require.Equal(t, core.StatusWarn, status.Status, "Expected WARN status from channel after Disable")
		require.Contains(t, status.Output, "RabbitMQ checker disabled", "Expected output to indicate disabled state")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for WARN status from channel after Disable")
	}

	checker.Enable()
	// Wait for the WARN status after enabling (re-initializing)
	select {
	case status := <-statusChan:
		require.Equal(t, core.StatusWarn, status.Status, "Expected WARN status from channel after Enable")
		require.Contains(t, status.Output, "RabbitMQ checker enabled, re-initializing...", "Expected output to indicate enabled state")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for WARN status from channel after Enable")
	}

	// Wait for the PASS status after a successful check post-enable
	select {
	case status := <-statusChan:
		require.Equal(t, core.StatusPass, status.Status, "Expected PASS status from channel after re-enable check")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for PASS status from channel after re-enable check")
	}
}

// TestRabbitMQHealthCheck_StatusChangeChannel verifies that the status change channel works.
func TestRabbitMQHealthCheck_StatusChangeChannel(t *testing.T) {
	ctx, cancel := context.WithTimeout(t.Context(), defaultTestTimeout)
	defer cancel()
	rabbitmqContainer, amqpURL, err := setupRabbitMQ(ctx)
	require.NoError(t, err)
	defer func() {
		if err := rabbitmqContainer.Terminate(ctx); err != nil {
			log.Printf("failed to terminate RabbitMQ container: %s", err)
		}
	}()

	descriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-status-channel",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check status change channel test",
	}

	checker := NewRabbitMQChecker(descriptor, 1*time.Second, 1*time.Second, amqpURL)
	defer func() {
		if err := checker.Close(); err != nil {
			assert.NoError(t, err)
		}
	}()

	statusChan := checker.StatusChange()

	// The initial status is WARN, but it immediately starts a health check
	// which will likely change the status to PASS very quickly.
	// We'll consume statuses from the channel until we see PASS.
	// We expect at least one status update.
	var initialStatus core.ComponentStatus
	select {
	case initialStatus = <-statusChan:
		// We might get WARN first, or PASS directly if the check is fast
		require.True(t, initialStatus.Status == core.StatusWarn || initialStatus.Status == core.StatusPass, "Expected initial status from channel to be WARN or PASS")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for initial status update")
	}

	// If the first status was WARN, wait for PASS. If it was PASS, we are good.
	if initialStatus.Status == core.StatusWarn {
		select {
		case status := <-statusChan:
			require.Equal(t, core.StatusPass, status.Status, "Expected PASS status from channel after initial WARN")
		case <-time.After(defaultTestTimeout):
			t.Fatal("Timeout waiting for PASS status after initial WARN")
		}
	} else {
		// If initial status was PASS, we are good to go.
		// No further action needed here.
	}

	// Test ChangeStatus causing a channel update
	newStatus := core.ComponentStatus{Status: core.StatusFail}
	checker.ChangeStatus(newStatus)
	select {
	case status := <-statusChan:
		require.Equal(t, core.StatusFail, status.Status, "Expected FAIL status from channel after ChangeStatus")
	case <-time.After(defaultTestTimeout):
		t.Fatal("Timeout waiting for FAIL status from channel")
	}
}

// TestRabbitMQHealthCheck_Descriptor verifies the Descriptor method.
func TestRabbitMQHealthCheck_Descriptor(t *testing.T) {
	expectedDescriptor := core.Descriptor{
		ComponentID:   "rabbitmq-test-descriptor",
		ComponentType: "rabbitmq",
		Description:   "RabbitMQ health check descriptor test",
	}

	checker := &rabbitMQChecker{
		descriptor: expectedDescriptor,
	}

	actualDescriptor := checker.Descriptor()
	require.Equal(t, expectedDescriptor, actualDescriptor, "Expected descriptor to match")
}

// TestRabbitMQHealthCheck_ConnectionCloseError verifies that an error during connection close is logged.
func TestRabbitMQHealthCheck_ConnectionCloseError(t *testing.T) {
	mockConn := newMockAMQPConnection()
	mockConn.SetCloseError(fmt.Errorf("mock connection close error"))

	descriptor := core.Descriptor{ComponentID: "test-close-conn-error", ComponentType: "rabbitmq"}
	checker := newRabbitMQCheckerInternal(descriptor, 10*time.Millisecond, 20*time.Millisecond, mockConn) // Short interval for quick check
	// Removed defer checker.Close() to prevent double close of quit channel

	// Wait for an initial health check to pass before attempting to close
	waitForStatus(t, checker, core.StatusPass, defaultTestTimeout)
	err := checker.Close()
	require.Error(t, err) // Checker.Close should return error from underlying connection close
	require.Contains(t, err.Error(), "mock connection close error")
}

// TestRabbitMQHealthCheck_ChannelOpenError verifies that the health check fails if opening a channel fails.
func TestRabbitMQHealthCheck_ChannelOpenError(t *testing.T) {
	mockConn := newMockAMQPConnection()
	mockConn.SetChannelError(fmt.Errorf("mock channel open error"))

	descriptor := core.Descriptor{ComponentID: "test-channel-open-error", ComponentType: "rabbitmq"}
	// Use NewRabbitMQCheckerWithOpenAMQPFunc to inject our mock connection.
	// We need a function that returns a *real* checker, but with our mock.
	openFunc := func(url string) (amqpConnection, error) {
		return mockConn, nil
	}
	checker := NewRabbitMQCheckerWithOpenAMQPFunc(descriptor, 10*time.Millisecond, 1*time.Second, "amqp://localhost", openFunc)
	defer func() {
		_ = checker.Close()
	}()

	// Wait for a health check to report failure due to channel open error
	waitForStatus(t, checker, core.StatusFail, defaultTestTimeout)

	status := checker.Status()
	require.Equal(t, core.StatusFail, status.Status)
	require.Contains(t, status.Output, "Failed to open RabbitMQ channel: mock channel open error")
}

// TestRabbitMQHealthCheck_ChannelCloseError verifies that an error during channel close is logged.
func TestRabbitMQHealthCheck_ChannelCloseError(t *testing.T) {
	mockChannel := newMockAMQPChannel()
	mockChannel.SetCloseError(fmt.Errorf("mock channel close error"))

	mockConn := newMockAMQPConnection()
	mockConn.mockChannel = mockChannel // Inject mockChannel into mockConn

	descriptor := core.Descriptor{ComponentID: "test-channel-close-error", ComponentType: "rabbitmq"}
	openFunc := func(url string) (amqpConnection, error) {
		return mockConn, nil
	}
	checker := NewRabbitMQCheckerWithOpenAMQPFunc(descriptor, 10*time.Millisecond, 1*time.Second, "amqp://localhost", openFunc)
	defer func() {
		_ = checker.Close()
	}()

	// Wait for a health check to pass, even if channel close errors (it's logged, not a failure of check itself)
	waitForStatus(t, checker, core.StatusPass, defaultTestTimeout)

	// The error from channel.Close() is logged, not returned by performHealthCheck,
	// so the checker's status should still be PASS if publish was successful.
	status := checker.Status()
	require.Equal(t, core.StatusPass, status.Status)
	require.Contains(t, status.Output, "RabbitMQ is healthy")
}

// TestRabbitMQHealthCheck_PublishError verifies that the health check fails if publishing a message fails.
func TestRabbitMQHealthCheck_PublishError(t *testing.T) {
	mockChannel := newMockAMQPChannel()
	mockChannel.SetPublishError(fmt.Errorf("mock publish error"))

	mockConn := newMockAMQPConnection()
	mockConn.mockChannel = mockChannel // Inject mockChannel into mockConn

	descriptor := core.Descriptor{ComponentID: "test-publish-error", ComponentType: "rabbitmq"}
	openFunc := func(url string) (amqpConnection, error) {
		return mockConn, nil
	}
	checker := NewRabbitMQCheckerWithOpenAMQPFunc(descriptor, 10*time.Millisecond, 1*time.Second, "amqp://localhost", openFunc)
	defer func() {
		_ = checker.Close()
	}()

	// Wait for a health check to report failure due to publish error
	waitForStatus(t, checker, core.StatusFail, defaultTestTimeout)

	status := checker.Status()
	require.Equal(t, core.StatusFail, status.Status)
	require.Contains(t, status.Output, "Failed to publish RabbitMQ test message: mock publish error")
}
