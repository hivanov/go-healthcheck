package vault

import (
	"fmt"
	"github.com/hivanov/go-healthcheck/src/core"
	"testing"
	"time" // Add time import

	"github.com/hashicorp/vault/api"
)

// FuzzPerformHealthCheck fuzzer for the performHealthCheck method.
func FuzzPerformHealthCheck(f *testing.F) {
	// Add a seed corpus (example inputs)
	f.Add(true, false, false, false, "", "", false) // Example: Healthy Vault
	f.Add(false, true, true, false, "", "", false)  // Example: Uninitialized Vault
	f.Add(true, true, false, false, "", "", false)  // Example: Sealed Vault

	f.Fuzz(func(t *testing.T, initialized, sealed, standby, performanceStandby bool, replicationPerformanceMode, replicationDRMode string, clientError bool) {
		// Create a mock VaultClient for the fuzzer
		var mockHealthResponse *api.HealthResponse
		var mockHealthError error

		if clientError {
			mockHealthError = fmt.Errorf("fuzzing-induced client error")
		} else {
			mockHealthResponse = &api.HealthResponse{
				Initialized:                initialized,
				Sealed:                     sealed,
				Standby:                    standby,
				PerformanceStandby:         performanceStandby,
				ReplicationPerformanceMode: replicationPerformanceMode,
				ReplicationDRMode:          replicationDRMode,
			}
		}

		mockClient := &mockVaultClient{
			healthResponse: mockHealthResponse,
			healthError:    mockHealthError,
		}

		descriptor := core.Descriptor{
			ComponentID:   "fuzz-vault",
			ComponentType: "vault",
			Description:   "Fuzz test Vault checker",
		}

		// Create a checker with a short interval for quick fuzzing iterations
		// and inject the mock client.
		checker := newVaultCheckerInternal(descriptor, 10*time.Millisecond, mockClient)
		if checker == nil {
			t.Skip("Failed to create fuzz checker")
		}
		defer func() {
			if err := checker.Close(); err != nil {
				t.Errorf("Error closing fuzz checker: %v", err)
			}
		}()

		// Give it some time to perform a health check
		time.Sleep(20 * time.Millisecond)

		// Assert that it didn't panic and the status is one of the expected ones.
		// The main goal of fuzzing is to find crashes/panics.
		status := checker.Status()
		if status.Status == "" {
			t.Errorf("Status should not be empty")
		}
		_ = checker.Health() // Ensure Health() doesn't panic
	})
}

// mockVaultClient and mockSysClient (from checker_test.go) are needed here as well
// but this file is in package vault, so it can't directly access types from vault_test.
// This indicates a potential design issue for fuzzing internal methods with test-only mocks.
// For fuzzing, it's often better to fuzz exported functions/methods directly or
// copy the mock types if they are simple enough and not introducing conflicts.

// For now, to make this compile, I will copy the mock definitions here.
// In a real project, these mocks might be in a separate internal test support package
// or the fuzz test would be in the same _test package.

type mockVaultClient struct {
	sysFunc        func() SysInterface
	closeFunc      func()
	healthResponse *api.HealthResponse
	healthError    error
}

func (m *mockVaultClient) Sys() SysInterface {
	if m.sysFunc != nil {
		return m.sysFunc()
	}
	return &mockSysClient{
		healthResponse: m.healthResponse,
		healthError:    m.healthError,
	}
}

func (m *mockVaultClient) Close() {
	if m.closeFunc != nil {
		m.closeFunc()
	}
}

type mockSysClient struct {
	healthResponse *api.HealthResponse
	healthError    error
}

func (m *mockSysClient) Health() (*api.HealthResponse, error) {
	return m.healthResponse, m.healthError
}
